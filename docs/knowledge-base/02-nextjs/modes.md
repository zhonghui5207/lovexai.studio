# 开发模式 vs 生产模式

## 📊 对比表

| 特性 | 开发模式 (`pnpm dev`) | 生产模式 (`pnpm build + start`) |
|------|----------------------|--------------------------------|
| 读取源代码 | ✅ 是 | ❌ 否 |
| 使用 `.next` | 临时缓存 | 必需文件 |
| 删除 `.next` | ✅ 自动重建 | ❌ 无法运行 |
| 编译方式 | 实时（慢） | 预先（快） |
| 代码优化 | ❌ 无 | ✅ 压缩/优化 |
| 热更新 | ✅ 支持 | ❌ 不支持 |
| 性能 | 慢 | 快 |

## 🔄 开发模式流程

```
你运行 pnpm dev
    ↓
Next.js 启动开发服务器
    ↓
读取源代码 (app/, components/)
    ↓
实时编译（JIT）
    ↓
写入 .next/（临时缓存）
    ↓
浏览器访问
    ↓
你修改代码
    ↓
热更新（自动刷新）
```

**特点**:
- 逐页编译
- 不优化代码
- 支持热更新
- `.next` 可丢弃

## 🏭 生产模式流程

```
你运行 pnpm build
    ↓
┌─────────────────────────────────────┐
│ 深度优化编译                         │
├─────────────────────────────────────┤
│ 1. TypeScript → JavaScript         │
│ 2. React 优化                       │
│ 3. 代码分割（Code Splitting）       │
│ 4. Tree-shaking（删除无用代码）     │
│ 5. 压缩混淆                         │
│ 6. 生成静态 HTML（SSG）             │
│ 7. 优化图片                         │
│ 8. 生成 standalone 服务器文件       │
└─────────────────────────────────────┘
    ↓
生成 .next/（优化后的代码）
    ↓
运行 node server.js（或 pnpm start）
    ↓
浏览器访问（性能优化）
```

## 🎯 关键差异

### 编译产物

```
开发模式 .next/:
├── 快速生成
├── 未优化
└── 可重建

生产模式 .next/:
├── 深度优化
├── 压缩混淆
├── 代码分割
└── 不可丢失
```

### 运行方式

```bash
# 开发模式
pnpm dev
# 读取源代码，实时编译，热更新

# 生产模式
pnpm build && pnpm start
# 运行编译后的代码，不再读取源代码
```

## 💡 实际使用场景

### 本地开发

```bash
rm -rf .next        # ✅ 可以删除
pnpm dev           # 自动重建
```

### 本地测试生产环境

```bash
pnpm build         # 生成 .next/
pnpm start         # 运行编译后的代码
# ❌ 删除 .next 后无法运行
```

### Docker 构建

```dockerfile
# Dockerfile
FROM base AS builder
RUN pnpm build      # 生成 .next/standalone/

FROM base AS runner
COPY --from=builder /app/.next/standalone ./
CMD ["node", "server.js"]  # 只需要编译产物
```

## 🔍 构建时间对比

```
开发模式启动: 1-2 秒（增量编译）
生产模式构建: 30-60 秒（完整优化）
生产模式启动: <1 秒（直接运行）
```

## 📝 记忆口诀

```
开发模式 = 写草稿
├── 随时修改
├── 随时重写
└── 涂了再写

生产模式 = 印刷书
├── 一次排版
├── 大量印刷
└── 不能改了

.next 目录:
├── 开发模式 = 草稿纸（随便撕）
├── 生产模式 = 印刷版（必须保留）
```

---

**结论**: 开发模式优先开发体验（热更新、快速反馈），生产模式优先性能（优化、压缩）。
