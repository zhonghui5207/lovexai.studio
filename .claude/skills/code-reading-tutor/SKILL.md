# Code Reading Tutor

## 简介
Code Reading Tutor 是一个教练式的工具，它不直接解释代码，而是教你**如何系统地阅读代码**。就像健身教练教你正确的动作，而不是替你举重。通过这个工具，你将学会一套可复用的代码阅读方法论。

## 适用场景

### 何时使用
- 需要阅读一个不熟悉的代码文件
- 想要系统地理解某个模块的实现
- 准备修改代码，需要先完全理解它
- 学习优秀代码的设计思路
- 代码审查（Review）前的准备

### 不适合的场景  
- 快速查找某个函数的作用（直接用代码搜索）
- 理解单个语法点（用 Code Explainer）
- 调试具体的 bug（用 Bug Detective）
- 梳理整个项目结构（用 Module Mapper）

## 核心阅读方法：四层渐进法

### Level 1：整体扫描（3-5分钟）
**目标**：建立第一印象，了解"这个文件大概是干什么的"

**关注点：**
- 文件名和路径（暗示了用途）
- 文件总行数（复杂程度）
- 引入的依赖（使用了哪些外部模块）
- 类名/函数名列表（有哪些能力）
- 注释和文档（如果有）

**输出：**
用一句话总结这个文件的作用

**检查清单：**
```markdown
## Level 1 扫描清单

- [ ] 文件路径：`_______________`
- [ ] 总行数：约 ___ 行
- [ ] 主要类名：`_______________`（如果有）
- [ ] 主要函数/方法：
  - `_______________`
  - `_______________`
  - `_______________`
- [ ] 引入的依赖：
  - `_______________`
  - `_______________`
- [ ] 我的一句话总结：
  这个文件是用来 _______________
```

---

### Level 2：找主干（5-10分钟）
**目标**：识别核心逻辑，了解"主要流程是什么"

**关注点：**
- **入口函数**：外部调用的第一个方法
- **主流程**：最重要的业务逻辑
- **关键判断**：重要的 if-else、switch 分支
- **调用链**：这个文件调用了哪些其他函数/类

**输出：**
画出函数调用关系图（文本版）

**检查清单：**
```markdown
## Level 2 主干识别

- [ ] 入口函数是：`_______________`
- [ ] 主流程步骤：
  1. _______________
  2. _______________
  3. _______________
  4. _______________

- [ ] 调用关系图：
  入口函数
    ↓ 调用
  函数A
    ↓ 调用
    ├─ 函数B
    └─ 函数C
      ↓ 调用
      外部类/方法

- [ ] 关键决策点：
  - 在第 ___ 行，根据 ___ 判断是否 ___
  - 在第 ___ 行，根据 ___ 选择 ___
```

---

### Level 3：看细节（10-20分钟）
**目标**：理解每个函数的实现，了解"为什么这样写"

**关注点：**
- **函数签名**：参数和返回值的含义
- **输入验证**：如何处理无效输入
- **核心算法**：关键的计算或转换逻辑
- **异常处理**：如何处理错误情况
- **边界条件**：特殊情况的处理

**输出：**
每个函数的"输入-处理-输出"描述

**检查清单：**
```markdown
## Level 3 细节分析

### 函数：`functionName()`

**函数签名：**
- 参数：
  - `param1` (类型): 作用_______________
  - `param2` (类型): 作用_______________
- 返回值：(类型) _______________

**核心逻辑：**
1. 验证参数：_______________
2. 处理数据：_______________
3. 调用外部服务：_______________
4. 组装结果：_______________
5. 返回数据：_______________

**异常处理：**
- 如果 ___ 出错，则 ___
- 如果 ___ 为空，则 ___

**边界条件：**
- 当 ___ 时，特殊处理：___
- 当 ___ 时，提前返回：___

**我不理解的点：**
- _______________
- _______________
```

---

### Level 4：画图总结（5-10分钟）
**目标**：用图形化的方式总结理解，便于记忆和后续回顾

**关注点：**
- 画出数据流向图
- 标注关键决策点
- 记录设计亮点
- 标记疑问点

**输出：**
- 流程图（手绘或文本）
- 理解总结
- 疑问列表

**检查清单：**
```markdown
## Level 4 图形化总结

### 数据流向图
[用文本或手绘]
输入数据
  ↓
验证处理
  ↓
[判断点] 是否有效?
  ├─ 是 → 继续处理
  └─ 否 → 返回错误
  ↓
调用外部服务
  ↓
组装结果
  ↓
返回输出

### 设计亮点
- ✅ 好的地方：_______________
- ✅ 值得学习：_______________

### 待改进点
- ⚠️ 可能的问题：_______________
- ⚠️ 可以优化：_______________

### 我的疑问
- ❓ 为什么要 ___ ？
- ❓ 这里的 ___ 是什么意思？

### 用自己的话总结
[用2-3句话说明你对这个文件的理解]
```

## 针对不同文件类型的阅读策略

### 控制器（Controller）
**重点关注：**
- 接收哪些 HTTP 请求
- 参数验证逻辑
- 调用哪些 Service/Logic
- 返回什么数据格式

**阅读顺序：**
1. 看所有的路由方法
2. 选一个最核心的方法深入看
3. 理解参数验证
4. 追踪调用链

---

### 业务逻辑层（Logic/Service）
**重点关注：**
- 核心业务规则
- 数据处理流程
- 调用的外部服务
- 事务处理

**阅读顺序：**
1. 找到主要的业务方法
2. 理解业务流程
3. 看异常处理
4. 看数据库操作

---

### 数据模型（Model）
**重点关注：**
- 数据库表结构
- 字段含义
- 关联关系
- 查询方法

**阅读顺序：**
1. 看表名和字段
2. 理解字段含义
3. 看关联关系（一对多、多对多）
4. 看自定义查询方法

---

### 前端组件（Vue/React）
**重点关注：**
- Props（属性）
- State（状态）
- 生命周期
- 事件处理
- API 调用

**阅读顺序：**
1. 看组件的 Props 和 State
2. 看模板/JSX（UI 结构）
3. 看主要的事件处理方法
4. 看 API 调用和数据处理

---

### 工具函数（Utils/Helpers）
**重点关注：**
- 函数的输入输出
- 核心算法
- 边界条件处理

**阅读顺序：**
1. 看函数签名
2. 看典型用例
3. 看核心算法
4. 看边界处理

## 实战指南

### 阅读前的准备
```markdown
## 阅读计划

**文件名：** `_______________`
**预计阅读时间：** ___ 分钟
**阅读目标：** 
- [ ] 了解这个文件是干什么的
- [ ] 理解核心业务逻辑
- [ ] 找到可以修改的地方
- [ ] 其他：_______________

**已知信息：**
- 这个文件是 ___ 模块的一部分
- 它被 ___ 调用
- 它负责处理 ___ 业务
```

### 阅读中的技巧

**技巧 1：边读边做笔记**
```markdown
## 阅读笔记

**第 50-80 行：**
这段代码在处理支付回调验证
- 先验证签名
- 再验证订单状态
- 疑问：为什么要验证两次？

**第 120-150 行：**
这段代码在更新订单
- 使用了事务
- 同时更新了用户余额
- 亮点：考虑了并发情况
```

**技巧 2：用注释标记理解**
在代码旁边写理解注释（不提交到代码库）：
```php
// 我的理解：这里是在创建支付订单
public function create($params) {
    // 我的理解：验证用户是否有权限
    $this->checkAuth($params['user_id']);
    
    // 我的理解：根据支付方式选择不同的处理器
    $service = PaymentFactory::create($params['pay_type']);
    
    // 我的理解：调用具体的支付服务
    return $service->pay($params);
}
```

**技巧 3：对比类似文件**
如果有类似的文件，对比阅读：
```markdown
## 对比 AliPayService 和 WechatPayService

### 相同点
- 都实现了 PaymentInterface 接口
- 都有 pay() 和 callback() 方法
- 都要验证签名

### 不同点
- 支付宝用 RSA2 签名，微信用 MD5
- 支付宝回调参数名是 xxx，微信是 yyy
- 支付宝要返回 success，微信要返回 XML

### 启发
下次要加新支付方式时，可以参考这个模式
```

### 阅读后的巩固

**巩固方法 1：用自己的话重新讲一遍**
```markdown
## 我的理解

这个 PaymentLogic.php 文件是支付模块的入口。

当用户要支付时：
1. 前端调用 create() 方法
2. create() 会先验证参数
3. 然后根据支付方式（支付宝/微信/余额）选择对应的 Service
4. 调用 Service 的 pay() 方法
5. 返回支付 URL 或者直接扣款

支付成功后：
1. 支付平台会回调 callback() 方法
2. callback() 先验证签名（防止伪造）
3. 然后更新订单状态
4. 如果是充值订单，还要给用户加余额
5. 最后返回 success 给支付平台

整体来说，这个文件就是一个"调度中心"，负责协调各个支付方式。
```

**巩固方法 2：画简化的流程图**
```
用户点击支付
  ↓
PaymentLogic.create()
  ↓
PaymentFactory.create(type)
  ↓
  ├─ type=alipay → AliPayService
  ├─ type=wechat → WechatPayService  
  └─ type=balance → BalanceService
  ↓
返回支付URL / 扣款结果
```

**巩固方法 3：提出改进建议**
```markdown
## 可以改进的地方

1. 缺少日志记录
   - 建议：在关键步骤加 log
   
2. 异常处理不够细致
   - 建议：区分不同类型的异常，返回不同的错误码

3. 硬编码太多
   - 建议：把配置项提取到 config 文件
```

## 使用示例

### 示例 1：阅读一个 Controller 文件

**用户：**
```
用 Code Reading Tutor 帮我阅读这个文件：
/server/app/controller/PaymentController.php
```

**Tutor 回复：**
```markdown
## 📖 阅读指导：PaymentController.php

好的！我们用四层渐进法来阅读这个文件。

### 🔍 Level 1：整体扫描（3分钟）

请先快速浏览这个文件，回答以下问题：

**扫描清单：**
- [ ] 这个文件有多少行？（大概看一下）
- [ ] 有哪些方法？（看方法名就行）
- [ ] 引入了哪些类？（看 use 语句）

完成后，用一句话告诉我：
"这个 Controller 是用来 _______________ 的"

---

等你完成 Level 1，我再引导你进入 Level 2 🎯
```

**用户：**
```
这个文件有 200 行左右
方法有：create, callback, query, refund
引入了 PaymentLogic, OrderModel, Logger

我的理解：这个 Controller 是用来处理支付相关的 HTTP 请求的
```

**Tutor 回复：**
```markdown
✅ 很好！你的理解是对的。

### 🎯 Level 2：找主干（10分钟）

现在我们深入一点，请重点看 `create()` 方法（最核心的方法）

**主干识别清单：**
1. create() 方法接收哪些参数？
2. 它的主要步骤是什么？（不用看细节，看大的步骤）
3. 它调用了哪些其他类/方法？
4. 它返回什么数据？

请在纸上画出 create() 方法的调用链：
create()
  ↓ 调用
  ??? 
  ↓ 调用
  ???

完成后告诉我你的发现 📝
```

---

### 示例 2：阅读一个复杂的 Service 文件

**用户：**
```
用 Code Reading Tutor 帮我阅读
/server/app/service/pay/AliPayService.php
这个文件有 500 行，看起来很复杂
```

**Tutor 回复：**
```markdown
## 📖 阅读指导：AliPayService.php

500 行确实有点多！我们需要策略性地阅读。

### 📋 阅读策略

对于这种复杂文件，我建议：
1. 不要逐行阅读（会晕）
2. 先找到最重要的 2-3 个方法
3. 重点理解核心流程
4. 其他方法可以暂时跳过

### 🔍 Step 1：快速定位（5分钟）

请快速浏览，找到：
- [ ] 这个类实现了什么接口？（类定义那一行）
- [ ] 有哪些 public 方法？（这些是外部会调用的）
- [ ] 哪个方法行数最多？（通常是最核心的）

不用理解细节，只是快速定位 🎯

---

### 🎯 Step 2：聚焦核心（20分钟）

找到后，我们聚焦阅读最重要的方法。

通常对于支付 Service，最重要的是：
1. `pay()` 方法 - 发起支付
2. `verify()` 方法 - 验证回调

我建议：
- ✅ 先重点看这两个方法
- ❌ 暂时跳过其他辅助方法

等你看完这两个方法，我们再决定是否需要看其他部分 👍
```

## 与其他 Skill 的配合

```markdown
## 学习路径

1️⃣ **Module Mapper** 
   ↓ 建立项目地图，知道要读哪些文件
   
2️⃣ **Code Reading Tutor** （你在这里）
   ↓ 学习如何系统地阅读代码
   
3️⃣ **Code Explainer**
   ↓ 理解具体代码的细节
   
4️⃣ **实践**
   ↓ 真正理解代码，能够修改
```

## 注意事项

### ✅ 好的阅读习惯
- 从整体到细节，不要上来就看代码
- 边读边做笔记，不要只是看
- 画图理解，不要只用文字
- 设定目标，不要漫无目的地读
- 及时总结，不要读完就忘

### ❌ 要避免的错误
- 逐行阅读（效率低，容易陷入细节）
- 不做笔记（看完就忘）
- 不画图（无法建立整体认知）
- 遇到不懂就放弃（应该标记疑问继续读）
- 追求完美理解（第一遍理解 80% 就很好）

### 💡 进阶技巧
- **对比阅读**：同时读两个类似的文件，理解设计模式
- **倒推阅读**：从调用处往回找实现
- **调试阅读**：边调试边看代码，理解执行路径
- **重构阅读**：阅读时思考"我会怎么写"

## 检验标准

读完一个文件后，你应该能：

✅ **理解层面**
- [ ] 用自己的话说明这个文件是干什么的
- [ ] 画出主要的函数调用关系
- [ ] 解释核心的业务逻辑
- [ ] 指出关键的决策点

✅ **应用层面**  
- [ ] 知道要修改某个功能应该改哪里
- [ ] 能预测修改会影响哪些地方
- [ ] 能发现明显的问题或可优化点

✅ **知识层面**
- [ ] 学到了某个设计模式
- [ ] 理解了某个架构思想
- [ ] 掌握了某个技术用法
```
